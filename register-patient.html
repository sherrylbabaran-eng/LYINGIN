<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Patient Registration</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- Bootstrap 5 CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css"/>
    
    <!-- Face-API for face detection -->
    <script async src="https://cdn.jsdelivr.net/npm/@vladmandic/face-api/dist/face-api.js"></script>
    
    <style>
        #mapContainer {
            height: 350px;
            border-radius: 5px;
            margin-bottom: 1rem;
            border: 1px solid #ddd;
        }
        
        #faceVerificationModal .modal-body {
            background: #f8f9fa;
        }
        
        #videoContainer {
            position: relative;
            width: 100%;
            max-width: 400px;
            margin: 0 auto;
            border: 2px solid #ddd;
            border-radius: 8px;
            overflow: hidden;
            background: #000;
        }
        
        #videoStream {
            width: 100%;
            display: block;
            transform: scaleX(-1);
        }
        
        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            display: none;
        }
        
        .face-box {
            border: 2px solid #28a745;
            border-radius: 4px;
            position: absolute;
            box-shadow: 0 0 10px rgba(40, 167, 69, 0.5);
        }
        
        .verification-status {
            padding: 10px 15px;
            border-radius: 4px;
            margin-top: 10px;
            text-align: center;
            font-weight: 500;
        }
        
        .status-success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .status-error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        .status-info {
            background-color: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
    </style>
</head>
<body class="bg-light">

<div class="container py-5">
    <div class="row justify-content-center">
        <div class="col-lg-8">

            <div class="card shadow-sm border-0">
                <div class="card-header bg-primary text-white text-center">
                    <h4 class="mb-0">Patient Registration</h4>
                    <small>Register as a Patient</small>
                </div>

                <div class="card-body p-4">

                    <!-- STEP INDICATOR -->
                    <ul class="nav nav-pills mb-4 justify-content-center" id="stepTabs">
                        <li class="nav-item">
                            <button class="nav-link active" type="button">Step 1</button>
                        </li>
                        <li class="nav-item">
                            <button class="nav-link disabled" type="button">Step 2</button>
                        </li>
                    </ul>

                    <form id="patientForm" enctype="multipart/form-data">

                        <!-- STEP 1: Personal Info -->
                        <div id="step1">
                            <h6 class="text-primary mb-3">Personal Information</h6>

                            <div class="row g-3 mb-4">
                                <div class="col-md-6">
                                    <label class="form-label">First Name</label>
                                    <input type="text" name="first_name" class="form-control" required>
                                </div>
                                <div class="col-md-6">
                                    <label class="form-label">Last Name</label>
                                    <input type="text" name="last_name" class="form-control" required>
                                </div>
                                <div class="col-md-6">
                                    <label class="form-label">Birthdate</label>
                                    <input type="date" name="birthdate" class="form-control" required>
                                </div>
                                <div class="col-md-6">
                                    <label class="form-label">Gender</label>
                                    <select name="gender" class="form-select" required>
                                        <option value="">Select Gender</option>
                                        <option value="male">Male</option>
                                        <option value="female">Female</option>
                                        <option value="other">Other</option>
                                    </select>
                                </div>
                                <div class="col-md-6">
                                    <label class="form-label">Email Address</label>
                                    <div class="input-group">
                                        <input type="email" id="emailInput" name="email" class="form-control" required>
                                        <button class="btn btn-outline-primary" type="button" id="verifyEmailBtn">Verify</button>
                                    </div>
                                    <div id="emailVerificationStatus" class="mt-2"></div>
                                </div>
                                <div class="col-md-6">
                                    <label class="form-label">Contact Number</label>
                                    <input type="text" name="contact_no" class="form-control" required>
                                </div>
                                <div class="col-12">
                                    <label class="form-label">Location on Map</label>
                                    <div id="mapContainer"></div>
                                    <small class="text-muted">Drag the pin to set your location</small>
                                </div>
                                <div class="col-12">
                                    <label class="form-label">Address</label>
                                    <textarea name="address" class="form-control" rows="2" placeholder="Drag pin on map to auto-fill" required></textarea>
                                </div>
                            </div>

                            <div class="d-flex justify-content-end">
                                <button type="button" class="btn btn-primary" id="nextBtn" disabled>Next</button>
                            </div>
                        </div>

                        <!-- STEP 2: Account & ID -->
                        <div id="step2" class="d-none">
                            <h6 class="text-primary mb-3">Account & ID Verification</h6>

                            <div class="row g-3 mb-4">
                                
                                <div class="col-md-6">
                                    <label class="form-label">Password</label>
                                    <input type="password" name="password" class="form-control" required>
                                </div>
                                <div class="col-md-6">
                                    <label class="form-label">Confirm Password</label>
                                    <input type="password" name="confirm_password" class="form-control" required>
                                </div>
                            </div>

                            <h6 class="text-primary mb-3">Valid ID Verification</h6>

                            <div class="row g-3 mb-4">
                                <div class="col-md-6">
                                    <label class="form-label">ID Type</label>
                                    <select id="idType" name="id_type" class="form-select" required>
                                        <option value="">Select ID</option>
                                        <option value="passport">Passport</option>
                                        <option value="drivers">Driver's License</option>
                                        <option value="national">National ID</option>
                                        <option value="philhealth">PhilHealth ID</option>
                                        <option value="sss">SSS ID</option>
                                    </select>
                                </div>

                                <div class="col-md-6">
                                    <label class="form-label">ID Number</label>
                                    <input type="text" id="idNumber" name="id_number" class="form-control" required>
                                    <small id="idFormatHelp" class="text-muted d-block small mt-1">Format depends on selected ID type. Select an ID type to see details.</small>
                                    <small class="text-danger d-none" id="idError">Invalid ID number format</small>
                                </div>

                                <div class="col-12">
                                    <label class="form-label">Upload Valid ID</label>
                                    <input type="file" id="idFile" name="idFile" class="form-control" accept="image/*,.pdf" required>
                                    <small class="text-danger d-none" id="fileError">Invalid file (JPG, PNG, PDF only / max 5MB)</small>
                                </div>

                                <div class="col-12">
                                    <label class="form-label">Face Verification <span class="badge bg-info ms-2">NEW</span></label>
                                    <button type="button" class="btn btn-outline-primary w-100" id="faceVerifyBtn" data-bs-toggle="modal" data-bs-target="#faceVerificationModal">
                                        <i class="bi bi-camera"></i> Verify Your Face
                                    </button>
                                    <small class="text-muted d-block mt-2">We'll verify your face matches your ID using AI technology</small>
                                    <div id="faceVerificationStatus" class="mt-2"></div>
                                </div>
                            </div>

                            <div class="form-check mb-4">
                                <input class="form-check-input" type="checkbox" required>
                                <label class="form-check-label">
                                    I agree to the <a href="#">Terms and Conditions</a>
                                </label>
                            </div>

                            <div class="d-flex justify-content-between">
                                <button type="button" class="btn btn-outline-secondary" id="prevBtn">Back</button>
                                <button type="submit" class="btn btn-primary btn-lg">Register Patient</button>
                            </div>

                            <p class="text-center mt-3 text-muted">
                                Already registered? <a href="index.html" data-bs-toggle="modal" data-bs-target="#loginModal" class="text-decoration-none">Login here</a>
                            </p>
                        </div>

                    </form>

                </div>
            </div>

        </div>
    </div>
</div>

<!-- FACE VERIFICATION MODAL -->
<div class="modal fade" id="faceVerificationModal" tabindex="-1" aria-labelledby="faceVerificationLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header bg-primary text-white">
                <h5 class="modal-title" id="faceVerificationLabel">
                    <i class="bi bi-camera"></i> Face Verification
                </h5>
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div id="videoContainer" class="mb-3" style="display: none;">
                    <video id="videoStream" autoplay playsinline></video>
                    <canvas id="canvas"></canvas>
                </div>
                
                <div id="faceCaptureArea" class="text-center mb-3">
                    <p class="text-muted mb-3">Please use your device camera to take a live photo for face verification</p>
                    <div class="d-flex justify-content-center gap-2">
                        <button type="button" class="btn btn-primary" id="useCameraBtn">
                            <i class="bi bi-camera-video"></i> Use Camera
                        </button>
                        <button type="button" class="btn btn-outline-secondary" id="torchToggleBtn" style="display:none;">
                            <i class="bi bi-lightbulb"></i> Turn On Flash
                        </button>
                    </div>
                    <small id="lightingHint" class="text-muted d-block mt-2">Good lighting improves face detection. Move to a brighter area if detection fails.</small>
                </div>

                <div id="previewArea" class="text-center mb-3" style="display: none;">
                    <p class="fw-bold mb-2">Face Photo Preview:</p>
                    <img id="previewImage" src="" style="max-width: 100%; max-height: 300px; border-radius: 8px;">
                </div>

                <div id="verificationResult" class="text-center"></div>
                <div id="detectionSpinner" class="spinner-border text-primary d-none" role="status" style="width:1.5rem;height:1.5rem;display:inline-block;margin-left:8px;vertical-align:middle;">
                    <span class="visually-hidden">Detecting...</span>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                <button type="button" class="btn btn-primary" id="capturePhotoBtn" style="display:none;">
                    <i class="bi bi-camera"></i> Capture Photo
                </button>
                <button type="button" class="btn btn-success" id="confirmFaceBtn" style="display: none;">
                    <i class="bi bi-check-circle"></i> Confirm Verification
                </button>
            </div>
        </div>
    </div>
</div>

<!-- OTP VERIFICATION MODAL -->
<div class="modal fade" id="otpVerificationModal" tabindex="-1" aria-labelledby="otpVerificationLabel" aria-hidden="true">
    <div class="modal-dialog modal-sm">
        <div class="modal-content">
            <div class="modal-header bg-primary text-white">
                <h5 class="modal-title" id="otpVerificationLabel">
                    <i class="bi bi-envelope"></i> Email Verification
                </h5>
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p class="text-muted text-center">We've sent a 6-digit code to your email. Please enter it below.</p>
                
                <form id="otpForm">
                    <div class="mb-3">
                        <label class="form-label">Verification Code</label>
                        <input type="text" id="otpInput" class="form-control form-control-lg text-center" 
                               placeholder="000000" maxlength="6" inputmode="numeric" required>
                        <small class="text-muted">Valid for 10 minutes</small>
                    </div>
                    
                    <div id="otpErrorMsg"></div>
                </form>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-primary" id="submitOtpBtn">Verify OTP</button>
            </div>
        </div>
    </div>
</div>

<!-- Bootstrap JS -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>

<!-- Leaflet JS -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>

<script>
// --- Map initialization ---
let map;
let marker;
const addressField = document.querySelector('textarea[name="address"]');

function initMap() {
    // Default location (Philippines center)
    const defaultLat = 12.8797;
    const defaultLng = 121.7740;
    
    map = L.map('mapContainer').setView([defaultLat, defaultLng], 13);
    
    // Add OpenStreetMap tiles
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '© OpenStreetMap contributors',
        maxZoom: 19
    }).addTo(map);
    
    // Add draggable marker (will be positioned by geolocation)
    marker = L.marker([defaultLat, defaultLng], { draggable: true }).addTo(map);
    
    // Update address when marker is dragged
    marker.on('dragend', () => {
        const latlng = marker.getLatLng();
        getAddressFromCoordinates(latlng.lat, latlng.lng);
    });
    
    // Also allow clicking on map to move marker
    map.on('click', (e) => {
        marker.setLatLng(e.latlng);
        getAddressFromCoordinates(e.latlng.lat, e.latlng.lng);
    });
    
    // Auto-detect user's location
    if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(
            (position) => {
                const lat = position.coords.latitude;
                const lng = position.coords.longitude;
                
                // Move map and marker to user's location
                map.setView([lat, lng], 15);
                marker.setLatLng([lat, lng]);
                
                // Auto-fill address
                getAddressFromCoordinates(lat, lng);
            },
            (error) => {
                console.log('Geolocation error:', error.message);
                // If geolocation fails, use default location already set
                getAddressFromCoordinates(defaultLat, defaultLng);
            }
        );
    } else {
        console.log('Geolocation not supported');
        getAddressFromCoordinates(defaultLat, defaultLng);
    }
}

function getAddressFromCoordinates(lat, lng) {
    // Use server-side proxy to avoid CORS issues (see: auth/api/reverse-geocode.php)
    const url = `auth/api/reverse-geocode.php?lat=${encodeURIComponent(lat)}&lon=${encodeURIComponent(lng)}`;

    // Show temporary status while we lookup
    addressField.value = 'Looking up address...';

    // Abort previous request if any to avoid race conditions
    if (window._reverseGeocodeAbort) {
        try { window._reverseGeocodeAbort.abort(); } catch (e) {}
    }
    const ac = new AbortController();
    window._reverseGeocodeAbort = ac;

    const doFetch = () => {
        return fetch(url, {
            signal: ac.signal,
            headers: {
                'X-Requested-With': 'XMLHttpRequest',
                'X-App-Client': 'PatientRegistration'
            }
        })
        .then(res => {
            if (!res.ok) return res.json().then(err => { throw new Error(err.error || ('HTTP ' + res.status)); });
            return res.json();
        })
        .then(data => {
            if (!data) throw new Error('Empty response');
            if (data.error) throw new Error(data.error);

            // Build complete address from address components when available
            const addr = data.address || {};
            const parts = [];

            if (addr.house_number && addr.road) {
                parts.push(`${addr.house_number} ${addr.road}`);
            } else if (addr.road) {
                parts.push(addr.road);
            }

            if (addr.village) parts.push(addr.village);
            if (addr.city_district) parts.push(addr.city_district);
            if (addr.city) parts.push(addr.city);
            if (addr.municipality) parts.push(addr.municipality);
            if (addr.province) parts.push(addr.province);
            if (addr.postcode) parts.push(addr.postcode);
            if (addr.country) parts.push(addr.country);

            const address = parts.length > 0 ? parts.join(', ') : (data.display_name || `Location: ${lat.toFixed(4)}, ${lng.toFixed(4)}`);
            addressField.value = address;
            return true;
        });
    };

    // Try once, then retry once after short delay on failure
    doFetch().catch(err => {
        console.error('Geocoding error (first attempt):', err);
        setTimeout(() => {
            doFetch().catch(err2 => {
                console.error('Geocoding error (retry):', err2);
                // Fallback to showing coordinates and asking user to verify
                addressField.value = `Location detected (${lat.toFixed(4)}, ${lng.toFixed(4)}) - Please verify address`;
            });
        }, 700);
    });
}

// Initialize map when page loads
window.addEventListener('load', initMap);

// --- Multi-step navigation ---
const step1 = document.getElementById('step1');
const step2 = document.getElementById('step2');
const nextBtn = document.getElementById('nextBtn');
const prevBtn = document.getElementById('prevBtn');
const stepTabs = document.querySelectorAll('#stepTabs .nav-link');

// Validate Step 1 fields and toggle Next button
function validateStep1Fields() {
    const firstName = document.querySelector('input[name="first_name"]').value.trim();
    const lastName = document.querySelector('input[name="last_name"]').value.trim();
    const birthdate = document.querySelector('input[name="birthdate"]').value;
    const gender = document.querySelector('select[name="gender"]').value;
    const email = document.querySelector('input[name="email"]').value.trim();
    const contact = document.querySelector('input[name="contact_no"]').value.trim();
    const address = document.querySelector('textarea[name="address"]').value.trim();

    const addressValid = address && address !== 'Looking up address...' && !address.startsWith('Location detected');
    const emailVerifiedFlag = (typeof verifiedEmail !== 'undefined' && verifiedEmail && verifiedEmail === email);

    const valid = firstName && lastName && birthdate && gender && email && contact && addressValid && emailVerifiedFlag;
    nextBtn.disabled = !valid;
    return valid;
}

// Hook validation to inputs
['input[name="first_name"]','input[name="last_name"]','input[name="birthdate"]','select[name="gender"]','input[name="email"]','input[name="contact_no"]','textarea[name="address"]'].forEach(selector => {
    const el = document.querySelector(selector);
    if (el) {
        el.addEventListener('input', validateStep1Fields);
    }
});

nextBtn.addEventListener('click', () => {
    // Validate Step 1 required fields before allowing progress to Step 2
    function showStepError(message) {
        let alertDiv = document.getElementById('step1Error');
        if (!alertDiv) {
            alertDiv = document.createElement('div');
            alertDiv.id = 'step1Error';
            alertDiv.className = 'alert alert-danger mb-3';
            const cardBody = document.querySelector('.card-body');
            cardBody.insertBefore(alertDiv, cardBody.firstChild);
        }
        alertDiv.textContent = message;
        // Auto-dismiss after 5s
        setTimeout(() => { if (alertDiv && alertDiv.parentNode) alertDiv.parentNode.removeChild(alertDiv); }, 5000);
    }

    const firstName = document.querySelector('input[name="first_name"]').value.trim();
    const lastName = document.querySelector('input[name="last_name"]').value.trim();
    const birthdate = document.querySelector('input[name="birthdate"]').value;
    const gender = document.querySelector('select[name="gender"]').value;
    const email = document.querySelector('input[name="email"]').value.trim();
    const contact = document.querySelector('input[name="contact_no"]').value.trim();
    const address = document.querySelector('textarea[name="address"]').value.trim();

    if (!firstName) { showStepError('Please enter First Name'); document.querySelector('input[name="first_name"]').focus(); return; }
    if (!lastName) { showStepError('Please enter Last Name'); document.querySelector('input[name="last_name"]').focus(); return; }
    if (!birthdate) { showStepError('Please enter Birthdate'); document.querySelector('input[name="birthdate"]').focus(); return; }
    if (!gender) { showStepError('Please select Gender'); document.querySelector('select[name="gender"]').focus(); return; }
    if (!email) { showStepError('Please enter Email'); document.querySelector('input[name="email"]').focus(); return; }
    if (!contact) { showStepError('Please enter Contact Number'); document.querySelector('input[name="contact_no"]').focus(); return; }
    if (!address || address === 'Looking up address...' || address.startsWith('Location detected')) {
        showStepError('Please set a valid address by dragging the pin or clicking the map');
        return;
    }

    // Ensure email has been verified using OTP flow
    if (typeof verifiedEmail === 'undefined' || !verifiedEmail || verifiedEmail !== email) {
        showStepError('Please verify your email before continuing');
        return;
    }

    // Clear any previous step error and proceed
    const old = document.getElementById('step1Error'); if (old) old.remove();

    step1.classList.add('d-none');
    step2.classList.remove('d-none');
    stepTabs[0].classList.remove('active');
    stepTabs[1].classList.remove('disabled');
    stepTabs[1].classList.add('active');
});

prevBtn.addEventListener('click', () => {
    step2.classList.add('d-none');
    step1.classList.remove('d-none');
    stepTabs[1].classList.remove('active');
    stepTabs[1].classList.add('disabled');
    stepTabs[0].classList.add('active');
});

// --- ID validation ---
const idNumber = document.getElementById('idNumber');
const idType = document.getElementById('idType');
const idFile = document.getElementById('idFile');
const idError = document.getElementById('idError');
const fileError = document.getElementById('fileError');

const idRules = {
    passport: /^[A-Z0-9]{6,9}$/i,
    drivers: /^[A-Z0-9\-]{5,20}$/i,
    national: /^\d{10,16}$/,
    philhealth: /^\d{12,14}$/,
    sss: /^\d{10,12}$/
};

idNumber.addEventListener('input', () => {
    const type = idType.value;
    let value = idNumber.value.trim();

    const normalizers = {
        passport: v => v.replace(/\s+/g, ''),
        drivers: v => v.replace(/[^A-Z0-9\-]/gi, ''),
        national: v => v.replace(/\D/g, ''),
        philhealth: v => v.replace(/\D/g, ''),
        sss: v => v.replace(/\D/g, '')
    };

    const normalize = normalizers[type] || (v => v);
    const normalized = normalize(value);

    // For numeric IDs, update the input to remove spaces/dashes for clarity
    if (['national', 'philhealth', 'sss'].includes(type)) {
        if (idNumber.value !== normalized) {
            idNumber.value = normalized;
            value = normalized;
        }
    }

    // Provide clearer error messages for each type (keep messages consistent with server validation)
    const errorMessages = {
        passport: 'Passport should be 6-9 letters/numbers',
        drivers: "Driver's License should be 5-20 characters (letters, numbers, dashes)",
        national: 'National/PhilSys ID should be 10-16 digits',
        philhealth: 'PhilHealth ID should be 12-14 digits',
        sss: 'SSS ID should be 10-12 digits'
    };

    if (!type || !idRules[type]?.test(normalized)) {
        idError.classList.remove('d-none');
        idNumber.classList.add('is-invalid');
        idError.textContent = errorMessages[type] || 'Invalid ID number format';
    } else {
        idError.classList.add('d-none');
        idNumber.classList.remove('is-invalid');
        idError.textContent = 'Invalid ID number format';
    }
});

// Helper for showing expected ID formats
function updateIdFormatHelp() {
    const help = document.getElementById('idFormatHelp');
    if (!help) return;
    const type = idType.value;
    const examples = {
        passport: 'Passport: 6-9 letters/numbers (e.g., A1234567).',
        drivers: "Driver\'s License: 5-20 characters (letters, numbers, dashes).",
        national: 'National/PhilSys: 10-16 digits (numbers only).',
        philhealth: 'PhilHealth: 12-14 digits (numbers only).',
        sss: 'SSS: 10-12 digits (numbers only).'
    };
    help.textContent = examples[type] || 'Select an ID type to see the expected format.';
}

// Re-validate when the ID type changes and update helper text
idType.addEventListener('change', () => {
    idNumber.dispatchEvent(new Event('input'));
    updateIdFormatHelp();
});

// Set initial helper text on load
updateIdFormatHelp();

idFile.addEventListener('change', () => {
    const file = idFile.files[0];
    const maxSize = 5 * 1024 * 1024;
    if (!file || file.size > maxSize || !file.type.match(/(image|pdf)/)) {
        fileError.classList.remove('d-none');
        idFile.classList.add('is-invalid');
        idFile.value = '';
    } else {
        fileError.classList.add('d-none');
        idFile.classList.remove('is-invalid');
    }
});

// --- Form submission with fetch ---
const patientForm = document.getElementById('patientForm');

patientForm.addEventListener('submit', e => {
    e.preventDefault();

    if (idNumber.classList.contains('is-invalid') || idFile.classList.contains('is-invalid') || !idType.value) {
        alert('Please provide a valid ID before submitting.');
        return;
    }

    // Check face verification status
    if (!window.faceVerificationComplete) {
        alert('Please complete face verification before registering.');
        return;
    }

    const formData = new FormData(patientForm);

    // Use a root-absolute API path to avoid relative-path 404s when served from nested pages
    fetch('/THESIS/LYINGIN/auth/api/register-patient.php', {
        method: 'POST',
        body: formData
    })
    .then(async res => {
        const text = await res.text();
        try {
            const data = JSON.parse(text);
            if (!res.ok) throw data;
            return data;
        } catch (e) {
            console.error('Non-JSON response from server:', text);
            throw { status: 'error', message: 'Server returned an unexpected response. Check console for details.', raw: text, statusCode: res.status };
        }
    })
    .then(data => {
        alert(data.message);
        if (data.status === 'success') {
            patientForm.reset();
            window.faceVerificationComplete = false;
            updateFaceVerificationUI();
            // Return to Step 1
            step2.classList.add('d-none');
            step1.classList.remove('d-none');
            stepTabs[1].classList.add('disabled');
            stepTabs[1].classList.remove('active');
            stepTabs[0].classList.add('active');
        }
    })
    .catch(err => {
        console.error('Registration Error:', err);
        const message = (err && err.message) ? err.message : 'An unexpected error occurred. Check console for details.';
        alert(message);
        if (err && err.raw) console.log('Server response (raw):', err.raw);
    });
});

// ===== FACE VERIFICATION SYSTEM =====
window.faceVerificationComplete = false;
let capturedFaceImage = null;
let capturedFaceDescriptor = null;
let idPhotoDescriptor = null;
let modelsLoaded = false;

const useCameraBtn = document.getElementById('useCameraBtn');
const capturePhotoBtn = document.getElementById('capturePhotoBtn');
const previewImage = document.getElementById('previewImage');
const previewArea = document.getElementById('previewArea');
const verificationResult = document.getElementById('verificationResult');
const confirmFaceBtn = document.getElementById('confirmFaceBtn');
const videoStream = document.getElementById('videoStream');
const videoContainer = document.getElementById('videoContainer');
const faceVerificationStatus = document.getElementById('faceVerificationStatus');
let cameraStream = null;
let videoTrack = null;
let imageCapture = null;
let lightingInterval = null;
let torchOn = false;

// Load face-api models
async function loadFaceModels() {
    if (modelsLoaded) return;
    
    try {
        const MODEL_URL = 'https://cdn.jsdelivr.net/npm/@vladmandic/face-api/model/';
        
        // Load both Tiny and SSD detection models if available (Tiny is faster)
        await faceapi.nets.tinyFaceDetector.loadFromUri(MODEL_URL);
        try { await faceapi.nets.ssdMobilenetv1.loadFromUri(MODEL_URL); } catch (e) { /* SSD not available, fallback to Tiny */ }
        await Promise.all([
            faceapi.nets.faceRecognitionNet.loadFromUri(MODEL_URL),
            faceapi.nets.faceLandmark68Net.loadFromUri(MODEL_URL),
            faceapi.nets.faceExpressionNet.loadFromUri(MODEL_URL)
        ]);
        
        modelsLoaded = true;
        console.log('Face API models loaded successfully');
    } catch (error) {
        console.error('Error loading face models:', error);
        showVerificationStatus('Error loading face detection models. Please try again.', 'error');
    }
}

// Extract face descriptor from image
async function extractFaceDescriptor(image) {
    const start = (typeof performance !== 'undefined') ? performance.now() : Date.now();
    try {
        // Try TinyFaceDetector first for speed, fallback to default detector if needed
        let detection = null;
        try {
            detection = await faceapi.detectSingleFace(image, new faceapi.TinyFaceDetectorOptions({ inputSize: 320, scoreThreshold: 0.4 })).withFaceLandmarks().withFaceDescriptor();
        } catch (e) {
            // Tiny may not be available; fallback
            detection = await faceapi.detectSingleFace(image).withFaceLandmarks().withFaceDescriptor();
        }

        const elapsed = Math.round(((typeof performance !== 'undefined') ? performance.now() : Date.now()) - start);

        if (!detection) {
            throw new Error('No face detected in image');
        }

        // detection.detection.score contains confidence for SSD/Tiny
        const score = detection.detection && typeof detection.detection.score === 'number' ? detection.detection.score : (detection.score || 0);
        window.lastDetectionTimeMs = elapsed;
        window.lastDetectionScore = score;

        // If confidence low, ask user to try again with better conditions
        const MIN_CONFIDENCE = 0.45;
        if (score < MIN_CONFIDENCE) {
            throw new Error(`Low detection confidence (${Math.round(score*100)}%). Try removing sunglasses, cleaning lens, improving lighting, or moving closer.`);
        }

        return detection.descriptor;
    } catch (error) {
        throw new Error(`Face detection failed: ${error.message}`);
    }
}

// Calculate Euclidean distance between two descriptors
function calculateDistance(descriptor1, descriptor2) {
    if (!descriptor1 || !descriptor2) return Infinity;
    let sum = 0;
    for (let i = 0; i < descriptor1.length; i++) {
        sum += Math.pow(descriptor1[i] - descriptor2[i], 2);
    }
    return Math.sqrt(sum);
}

// Show verification status
function showVerificationStatus(message, type = 'info') {
    const statusDiv = document.createElement('div');
    statusDiv.className = `verification-status status-${type}`;
    statusDiv.textContent = message;
    verificationResult.innerHTML = '';
    verificationResult.appendChild(statusDiv);
}

// Compute average brightness from a canvas (center region)
function getAverageBrightness(canvas) {
    const ctx = canvas.getContext('2d');
    const w = Math.max(10, Math.round(canvas.width * 0.15));
    const h = Math.max(10, Math.round(canvas.height * 0.15));
    const sx = Math.round((canvas.width - w) / 2);
    const sy = Math.round((canvas.height - h) / 2);
    try {
        const imageData = ctx.getImageData(sx, sy, w, h).data;
        let total = 0, count = 0;
        for (let i = 0; i < imageData.length; i += 4) {
            const r = imageData[i], g = imageData[i+1], b = imageData[i+2];
            const lum = 0.2126 * r + 0.7152 * g + 0.0722 * b;
            total += lum; count++;
        }
        return total / count;
    } catch (e) {
        return 255; // can't sample yet
    }
}

// Periodically check lighting and disable capture if too dark
function checkLighting() {
    if (!videoStream || videoStream.readyState < 2) return;
    const temp = document.createElement('canvas');
    const vw = videoStream.videoWidth || 320;
    const vh = videoStream.videoHeight || 240;
    const w = Math.max(30, Math.round(vw * 0.2));
    const h = Math.max(30, Math.round(vh * 0.2));
    temp.width = w; temp.height = h;
    const ctx = temp.getContext('2d');
    try {
        ctx.drawImage(videoStream, Math.round((vw-w)/2), Math.round((vh-h)/2), w, h, 0, 0, w, h);
        const avg = getAverageBrightness(temp);
        const hint = document.getElementById('lightingHint');
        if (avg < 50) {
            hint.textContent = 'Low light detected. Please improve lighting or enable flash.';
            capturePhotoBtn.disabled = true;
        } else {
            hint.textContent = 'Lighting looks good.';
            capturePhotoBtn.disabled = false;
        }
    } catch (e) {}
}

// Toggle device torch (if supported)
async function toggleTorch() {
    if (!videoTrack || !videoTrack.applyConstraints) return;
    torchOn = !torchOn;
    try {
        await videoTrack.applyConstraints({ advanced: [{ torch: torchOn }] });
        const btn = document.getElementById('torchToggleBtn');
        btn.innerHTML = torchOn ? '<i class="bi bi-lightbulb-fill"></i> Flash On' : '<i class="bi bi-lightbulb"></i> Turn On Flash';
    } catch (err) {
        console.warn('Torch toggle failed:', err);
    }
}

// Simple canvas enhancement: adjust brightness towards a target and add slight contrast
function enhanceCanvas(canvas) {
    const ctx = canvas.getContext('2d');
    const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imgData.data;
    let sum = 0;
    for (let i = 0; i < data.length; i += 4) {
        sum += (0.2126 * data[i] + 0.7152 * data[i+1] + 0.0722 * data[i+2]);
    }
    const avg = sum / (data.length / 4 || 1);
    const target = 110;
    const adjust = target / (avg || 1);
    const contrast = 1.05;

    for (let i = 0; i < data.length; i += 4) {
        data[i] = Math.min(255, Math.max(0, ((data[i] - 128) * contrast + 128) * adjust));
        data[i+1] = Math.min(255, Math.max(0, ((data[i+1] - 128) * contrast + 128) * adjust));
        data[i+2] = Math.min(255, Math.max(0, ((data[i+2] - 128) * contrast + 128) * adjust));
    }
    ctx.putImageData(imgData, 0, 0);
}

// Show face verification status
function showFaceVerificationStatus(message, type = 'info') {
    const statusDiv = document.getElementById('faceVerificationStatus');
    statusDiv.innerHTML = `<div class="alert alert-${type} mb-0 small">${message}</div>`;
}

// Update face verification UI
function updateFaceVerificationUI() {
    const statusDiv = document.getElementById('faceVerificationStatus');
    
    if (window.faceVerificationComplete) {
        statusDiv.innerHTML = '<div class="verification-status status-success"><i class="bi bi-check-circle"></i> Face verification complete!</div>';
    } else {
        statusDiv.innerHTML = '';
    }
}

// Camera flow
useCameraBtn.addEventListener('click', startCamera);

async function startCamera() {
    try {
        await loadFaceModels();
        videoContainer.style.display = 'block';
        previewArea.style.display = 'none';
        showVerificationStatus('Starting camera...', 'info');

        // Prefer a good resolution for face detection; the browser will use supported constraints
        const constraints = { video: { facingMode: 'user', width: { ideal: 1280 }, height: { ideal: 720 }, frameRate: { ideal: 30 } }, audio: false };
        cameraStream = await navigator.mediaDevices.getUserMedia(constraints);
        videoStream.srcObject = cameraStream;
        videoStream.play();

        // Setup track and ImageCapture if available
        videoTrack = cameraStream.getVideoTracks()[0];
        try { imageCapture = (typeof ImageCapture !== 'undefined' && videoTrack) ? new ImageCapture(videoTrack) : null; } catch (e) { imageCapture = null; }

        // Torch support
        const capabilities = videoTrack.getCapabilities ? videoTrack.getCapabilities() : {};
        const torchBtn = document.getElementById('torchToggleBtn');
        if (capabilities.torch) {
            torchBtn.style.display = 'inline-block';
            torchBtn.onclick = toggleTorch;
        } else {
            torchBtn.style.display = 'none';
        }

        // Start periodic lighting check to advise user
        lightingInterval = setInterval(checkLighting, 600);

        // Ensure capture button is visible and enabled
        capturePhotoBtn.style.display = 'inline-block';
        capturePhotoBtn.disabled = false;
        showVerificationStatus('Camera ready. Position your face and press Capture.', 'info');
    } catch (error) {
        console.error('Camera error:', error);
        showVerificationStatus('Unable to access camera. Please allow camera access or use a supported device.', 'error');
    }
} 

function stopCamera() {
    if (lightingInterval) { clearInterval(lightingInterval); lightingInterval = null; }
    if (cameraStream) {
        cameraStream.getTracks().forEach(t => t.stop());
        cameraStream = null;
    }
    // turn off torch if active
    if (torchOn && videoTrack && videoTrack.applyConstraints) {
        try { videoTrack.applyConstraints({ advanced: [{ torch: false }] }); } catch (e) {}
        torchOn = false;
    }
    imageCapture = null;
    videoTrack = null;
    videoStream.srcObject = null;
    videoContainer.style.display = 'none';
    capturePhotoBtn.style.display = 'none';
    const torchBtn = document.getElementById('torchToggleBtn'); if (torchBtn) torchBtn.style.display = 'none';

    // Ensure spinner hidden
    hideDetectionSpinner();
}

function showDetectionSpinner() {
    const s = document.getElementById('detectionSpinner'); if (s) s.classList.remove('d-none');
}
function hideDetectionSpinner() {
    const s = document.getElementById('detectionSpinner'); if (s) s.classList.add('d-none');
} 

capturePhotoBtn.addEventListener('click', async () => {
    try {
        // Freeze and capture frame
        showVerificationStatus('Capturing photo...', 'info');
        capturePhotoBtn.disabled = true;

        const canvas = document.getElementById('canvas');
        // Downscale for faster detection (target width)
        const targetWidth = 320;
        const videoWidth = videoStream.videoWidth || 640;
        const videoHeight = videoStream.videoHeight || 480;
        const scale = videoWidth / targetWidth;
        canvas.width = targetWidth;
        canvas.height = Math.round(videoHeight / scale);
        const ctx = canvas.getContext('2d');
        ctx.drawImage(videoStream, 0, 0, canvas.width, canvas.height);

        // Quick brightness check and enhancement
        const avg = getAverageBrightness(canvas);
        if (avg < 50) {
            showVerificationStatus('Lighting too low. Please increase lighting or enable flash.', 'error');
            capturePhotoBtn.disabled = false;
            // restart camera to allow the user to adjust
            startCamera();
            return;
        }

        // Apply simple enhancement to improve detection in suboptimal lighting
        enhanceCanvas(canvas);

        const dataUrl = canvas.toDataURL('image/jpeg');

        // Stop camera immediately to freeze the UI and reduce CPU
        stopCamera();

        // Show preview (frozen frame)
        previewImage.src = dataUrl;
        previewArea.style.display = 'block';

        // Run face detection on a smaller frame to speed up processing
        const img = new Image();
        img.onload = async () => {
            try {
                showVerificationStatus('Detecting face...', 'info');
                showDetectionSpinner();
                capturedFaceDescriptor = await extractFaceDescriptor(img);
                hideDetectionSpinner();
                capturedFaceImage = img;

                // Show detection metrics
                if (window.lastDetectionTimeMs !== undefined && window.lastDetectionScore !== undefined) {
                    showVerificationStatus(`Face detected (score: ${Math.round(window.lastDetectionScore*100)}%, ${window.lastDetectionTimeMs} ms)`, 'success');
                } else {
                    showVerificationStatus('Face detected', 'success');
                }

                // Compare with ID photo if available
                if (idPhotoDescriptor) {
                    compareFaces();
                } else {
                    confirmFaceBtn.style.display = 'none';
                }
            } catch (err) {
                hideDetectionSpinner();
                showVerificationStatus(err.message, 'error');
                // allow retry: re-enable capture and restart camera
                capturePhotoBtn.disabled = false;
                startCamera();
            }
        };
        img.src = dataUrl;
    } catch (err) {
        console.error('Capture error:', err);
        showVerificationStatus('Error capturing photo. Please try again.', 'error');
        capturePhotoBtn.disabled = false;
    }
});

// Stop camera when modal closes
document.getElementById('faceVerificationModal').addEventListener('hidden.bs.modal', stopCamera);

// Handle ID photo for comparison
idFile.addEventListener('change', async (event) => {
    const file = event.target.files[0];
    
    if (!file) return;
    
    // If it's a PDF, we can't extract face from it
    if (file.type === 'application/pdf') {
        console.log('PDF uploaded - Face comparison will be done manually');
        idPhotoDescriptor = null;
        return;
    }
    
    try {
        await loadFaceModels();
        
        const reader = new FileReader();
        reader.onload = async (e) => {
            const img = new Image();
            img.onload = async () => {
                try {
                    idPhotoDescriptor = await extractFaceDescriptor(img);
                    console.log('ID face extracted successfully');
                    
                    // If we already have a captured face, compare them
                    if (capturedFaceDescriptor) {
                        compareFaces();
                    }
                } catch (error) {
                    console.log('Could not extract face from ID photo:', error.message);
                    idPhotoDescriptor = null;
                }
            };
            img.src = e.target.result;
        };
        reader.readAsDataURL(file);
    } catch (error) {
        console.error('Error processing ID photo:', error);
    }
});

// Compare captured face with ID photo using Euclidean distance (lower is better)
function compareFaces() {
    if (!capturedFaceDescriptor || !idPhotoDescriptor) {
        showVerificationStatus('Both face photo and ID are required for verification.', 'error');
        confirmFaceBtn.style.display = 'none';
        return;
    }

    const distance = calculateDistance(capturedFaceDescriptor, idPhotoDescriptor);
    const thresholdDistance = 0.6; // typical threshold: <=0.6 indicates a likely match
    const isMatching = distance <= thresholdDistance;

    // Debugging info
    console.log('Face distance:', distance, 'threshold:', thresholdDistance);

    if (isMatching) {
        const matchPercent = Math.max(0, Math.round((1 - (distance / thresholdDistance)) * 100));
        showVerificationStatus(
            `✓ Face Match Verified! (distance: ${distance.toFixed(3)} — approx ${matchPercent}% confidence) Your face matches your ID.`,
            'success'
        );
        confirmFaceBtn.style.display = 'inline-block';
    } else {
        const matchPercent = Math.max(0, Math.round((1 - (distance / (thresholdDistance*2))) * 100));
        showVerificationStatus(
            `✗ Face Match Failed (distance: ${distance.toFixed(3)} — low confidence ${matchPercent}%). The face in your photo doesn't match your ID. Please upload a clearer photo or retake the live photo.`,
            'error'
        );
        confirmFaceBtn.style.display = 'none';
    }
}

// Confirm face verification
confirmFaceBtn.addEventListener('click', () => {
    window.faceVerificationComplete = true;
    updateFaceVerificationUI();

    // Ensure the form includes a hidden flag so the server knows face was confirmed
    let hidden = document.getElementById('hiddenFaceVerified');
    if (!hidden) {
        hidden = document.createElement('input');
        hidden.type = 'hidden';
        hidden.id = 'hiddenFaceVerified';
        hidden.name = 'face_verified';
        document.getElementById('patientForm').appendChild(hidden);
    }
    hidden.value = '1';

    // Show success message
    const modal = bootstrap.Modal.getInstance(document.getElementById('faceVerificationModal'));
    modal.hide();

    alert('Face verification complete! You can now submit your registration.');
});

// Initialize face models and start camera when modal opens
document.getElementById('faceVerificationModal').addEventListener('show.bs.modal', async () => {
    await loadFaceModels();
    // auto-start camera for convenience
    startCamera();
});

// ========== OTP VERIFICATION SYSTEM ==========
let verifiedEmail = null;

const emailInput = document.getElementById('emailInput');
const verifyEmailBtn = document.getElementById('verifyEmailBtn');
const emailVerificationStatus = document.getElementById('emailVerificationStatus');

verifyEmailBtn.addEventListener('click', async function() {
    const email = emailInput.value.trim();
    
    // Validate email format
    if (!email || !email.includes('@')) {
        showEmailStatus('Please enter a valid email address', 'danger');
        return;
    }
    
    // Send OTP (try multiple candidate paths to handle differing server base paths)
    verifyEmailBtn.disabled = true;
    verifyEmailBtn.textContent = 'Sending OTP...';

    const candidates = [
        'auth/api/send-otp.php',
        '/THESIS/LYINGIN/auth/api/send-otp.php',
        '/THESIS/LYINGIN/auth/api/send-otp.php'
    ];

    async function tryPostCandidates(candidateUrls, body) {
        let lastError = null;
        for (const url of candidateUrls) {
            try {
                console.log('Attempting OTP send to:', url);
                const resp = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                    body
                });
                const text = await resp.text();
                // If server returned HTML (404 page etc.) JSON.parse will throw and we'll treat it as failure
                let data = null;
                try { data = JSON.parse(text); } catch (e) { throw { url, status: resp.status, raw: text } }
                if (!resp.ok) throw { url, status: resp.status, data };
                return data;
            } catch (err) {
                console.warn('OTP attempt failed for', url, err);
                lastError = err;
            }
        }
        throw lastError || new Error('All candidate endpoints failed');
    }

    try {
        const data = await tryPostCandidates(candidates, 'email=' + encodeURIComponent(email) + '&user_type=patient');
        if (data.status === 'success') {
            showEmailStatus('OTP sent! Check your email.', 'success');
            showOTPModal(email);
        } else {
            showEmailStatus(data.message || 'Failed to send OTP', 'danger');
            verifyEmailBtn.disabled = false;
            verifyEmailBtn.textContent = 'Verify';
        }
    } catch (error) {
        console.error('Error sending OTP (all candidates failed):', error);
        // If the server sent back raw HTML for a 404, include a helpful message
        if (error && error.raw) console.log('Server response (raw):', error.raw);
        showEmailStatus('Error sending OTP. Server endpoint not found or returned an error. Check console.', 'danger');
        verifyEmailBtn.disabled = false;
        verifyEmailBtn.textContent = 'Verify';
    }
});

function showEmailStatus(message, type) {
    emailVerificationStatus.innerHTML = `<div class="alert alert-${type} mb-0 small">${message}</div>`;
}

function showOTPModal(email) {
    const otpModal = new bootstrap.Modal(document.getElementById('otpVerificationModal'));
    
    const otpForm = document.getElementById('otpForm');
    const otpInput = document.getElementById('otpInput');
    const submitOtpBtn = document.getElementById('submitOtpBtn');
    const otpErrorMsg = document.getElementById('otpErrorMsg');
    
    otpInput.value = '';
    otpErrorMsg.innerHTML = '';
    submitOtpBtn.disabled = false;
    submitOtpBtn.textContent = 'Verify OTP';
    
    submitOtpBtn.onclick = async function() {
        const otp = otpInput.value.trim();
        
        if (!otp || otp.length !== 6) {
            otpErrorMsg.innerHTML = '<div class="alert alert-danger mb-0 small">Please enter a 6-digit OTP</div>';
            return;
        }
        
        submitOtpBtn.disabled = true;
        submitOtpBtn.textContent = 'Verifying...';
        
        try {
            const candidates = [
                'auth/api/verify-otp.php',
                '/THESIS/LYINGIN/auth/api/verify-otp.php',
                '/THESIS/LYINGIN/auth/api/verify-otp.php'
            ];

            const verifyResp = await (async () => {
                for (const url of candidates) {
                    try {
                        console.log('Attempting OTP verify to:', url);
                        const resp = await fetch(url, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                            body: 'email=' + encodeURIComponent(email) + '&otp=' + encodeURIComponent(otp)
                        });
                        const text = await resp.text();
                        try { const data = JSON.parse(text); if (!resp.ok) throw { url, status: resp.status, data }; return data; } catch (e) { throw { url, status: resp.status, raw: text }; }
                    } catch (err) {
                        console.warn('OTP verify attempt failed for', url, err);
                        continue;
                    }
                }
                throw new Error('All OTP verify endpoints failed');
            })();

            const data = verifyResp;
            
            if (data.status === 'success') {
                verifiedEmail = email;
                // Don't disable the input (disabled inputs are not submitted). Use readOnly so the value is still posted.
                emailInput.readOnly = true;
                // Also keep a hidden input as a fallback to ensure the email is always submitted
                let hiddenEmail = document.getElementById('hiddenVerifiedEmail');
                if (!hiddenEmail) {
                    hiddenEmail = document.createElement('input');
                    hiddenEmail.type = 'hidden';
                    hiddenEmail.id = 'hiddenVerifiedEmail';
                    hiddenEmail.name = 'email';
                    document.getElementById('patientForm').appendChild(hiddenEmail);
                }
                hiddenEmail.value = email;

                verifyEmailBtn.disabled = true;
                verifyEmailBtn.classList.add('btn-success');
                verifyEmailBtn.classList.remove('btn-outline-primary');
                verifyEmailBtn.textContent = '✓ Verified';
                
                showEmailStatus('Email verified successfully!', 'success');
                otpModal.hide();
                
                // Re-run validation to enable Next when all fields are valid
                validateStep1Fields();
            } else {
                otpErrorMsg.innerHTML = '<div class="alert alert-danger mb-0 small">' + (data.message || 'Invalid OTP') + '</div>';
                submitOtpBtn.disabled = false;
                submitOtpBtn.textContent = 'Verify OTP';
            }
        } catch (error) {
            console.error('Error:', error);
            otpErrorMsg.innerHTML = '<div class="alert alert-danger mb-0 small">Error verifying OTP. Please try again.</div>';
            submitOtpBtn.disabled = false;
            submitOtpBtn.textContent = 'Verify OTP';
        }
    };
    
    otpModal.show();
}

// Block form submission if email not verified OR face not verified
document.getElementById('patientForm').addEventListener('submit', function(e) {
    if (!verifiedEmail) {
        e.preventDefault();
        showEmailStatus('Please verify your email first before registering', 'danger');
        return false;
    }
    
    if (!window.faceVerificationComplete) {
        e.preventDefault();
        showFaceVerificationStatus('Please complete face verification before registering', 'danger');
        return false;
    }
});

</script>

</body>
</html>
